HECHO---->TODOS LOS PUNTOS HECHOS
PENDIENTE--->QUEDA POR HACER
REVISAR---->Mirar un poco
MODIFICAR---->Es recomendable cambiarlo
#####################################
Instalado:
-> git: 
-> docker: sudo apt install docker.io
-> iptables: 
-> python3 instalado 
#####################################
->Fotos sin copyRight: https://www.freepik.es/fotos-vectores-gratis/informatica
->Carpeta static y templates establecida para los ficheros HTMLS, CSS, JS e imágenes
->Creada una aplicación "gestion" dentro del poryecto la cual gestiona todos los usuarios
->Establecida la DB "en pañales" desde el fichero "models.py" de gestion (creado)
->Para tener acceso desde otro ordenador he modificado la macro ALLOWED_HOSTS = ["192.168.1.25"] de settings.py
->Crear un sistema de registro de usuarios HECHO (REVISAR)
->Crear el sistema de login de un usuarios HECHO (REVISAR)
	-Que te de la bienvendia con todos los datos (Mirar si es mejor arrastrar el usuario por defecto de Django o el perfil creado por nosotros): HECHO (REVISAR bien)
		+Se hace mediantes un forms.py min 23:58 https://www.youtube.com/watch?v=06aDhOwqvfY&t=2004s
	-Que se gestione la sesion: https://developer.mozilla.org/es/docs/Learn/Server-side/Django/Sessions HECHO (Se hace mediante login_required)
	-Que tenga establecido un tiempo de session https://es.stackoverflow.com/questions/433071/c%C3%B3mo-puedo-controlar-el-tiempo-de-sesi%C3%B3n-del-usuario PENDIENTE (Echar un ojo, se ha creado una macro llamada SESSION_COOKIE_AGE en settings)
->Crear un logout de la sesion HECHO
->Cuando se intente acceder a un recurso sin usuario identificado-> redirect a la pagina principal HECHO (REVISAR->Poner el decorator en cada función que no se quiera tener acceso)
------
->Crear botones para levantar una maquina con doker y tener acceso a ella:
	+Controlar que un usuario pueda darle una sola vez al boton (HECHO)
	+Para cada usuario tengo que crear un contenedor individual con conectividad directa a dicho contenedor para que pueda vulnerar la maquina
->Mirar el formulario del indice para que cuando se dé a submit se mande un correo al administrador para cualquier incidencia
->Investigar Docker de caracter urgente
-----12-11-2023---------
->Para poder generar una imagen del modelo de datos (Base de Datos):
	+ Instalar: pip install django-extensions
	+ sudo pip install pydotplus && (REVISAR No esta instalado)pip install pygraphviz && apt-get install graphviz
	+ python3 manage.py graph_models -a -g -o my_models.png
->Levantar una maquina tiene una ruta /my/maquinas/nombreMaquina/activar o desactivar lo mejor es que la variable activar o desactivar vaya como un parámetro en POST: HECHO
->Levantar y detener una maquina sin linea de comandos con la API de docker PENDIENTE
->Establecer un enlace a la pagina oficial de fciencias
--------------
Script de importacón de una nueva maquinas vulnerable (PENDIENTE)
-----24-11-2023---------
Añadido el parametro LOGGIN para el registro de peticiones
-----14-02-2024---------
Para las traducciones del ingles al español:
-> Añadir al setting.py: USE_I18N = True
-> instalar: # sudo apt-get install gettext
-> crear una carpeta "locale" dentro de la aplicación
-> Ejecutar: # python manage.py makemessages -l es
	Esto creará archivos .po en el directorio locale/es/LC_MESSAGES/. Abre el archivo correspondiente (django.po)
->Editar el fichero poniendo: 	msgid "The two password fields didn't match."
				msgstr "Las dos contraseñas no coinciden."
-> Guardar con: # python manage.py compilemessages
==> No funciona mirar errores (PENDIENTE)
-----15-02-2024---------
-Para usar un servidor web usar guicon para ello instalarlo:# apt install gunicorn
-Añadir en la aplicacion principal del proyecto el fichero wsgi.py
- Para ejecutar y que funcione todo pero no es seguro: python3 manage.py runserver --insecure
-----16-02-2024---------
-Probandolo en el servidor de apache
-> instalo el modulo wsgi: # sudo apt install libapache2-mod-wsgi
	-> si no funciona: # sudo apt-get install libapache2-mod-wsgi-py3
-> lo activo: # sudo a2enmod wsgi
-Creo un fichero en la ruta:/etc/apache2/sites-available/marpaga.conf
	====================
	<VirtualHost *:80>
	    ServerName tu_domino.com
	    DocumentRoot /home/marco/Escritorio/TFG/marpaga_tfg

	    WSGIDaemonProcess marpaga_env python-home=/home/marco/Escritorio/TFG/virtual
	    WSGIProcessGroup marpaga_tfg
	    WSGIScriptAlias / /home/marco/Escritorio/TFG/marpaga_tfg/marpaga/wsgi.py

	    <Directory /home/marco/Escritorio/TFG/marpaga_tfg/marpaga>
		<Files wsgi.py>
		    Require all granted
		</Files>
	    </Directory>

	    Alias /static/ /home/marco/Escritorio/TFG/marpaga_tfg/gestion/
	    <Directory /home/marco/Escritorio/TFG/marpaga_tfg/gestion>
		Require all granted
	    </Directory>

	    #ErrorLog ${APACHE_LOG_DIR}/error.log
	    #CustomLog ${APACHE_LOG_DIR}/access.log combined
	     ErrorLog /home/marco/Escritorio/marpaga_error.log
	     CustomLog /home/marco/Escritorio/marpaga_access.log combined
	</VirtualHost>
	====================
--> ¡Para que funcione todo correctamente hay que mirar bien los permisos! (Pendiente de hacer)
	-----16-02-2024---------
	- Se han gestionado los botones de activación/desactivación de los usuario en redes y contenedores diferentes
	- Mostrar la ip al activar la maquina
	HECHO de hacer:
	1. Gestionar levantar un docker compose al darle al boton de activar en una red y usuario diferentes (HECHO) REVISAR-> Usar la api docker-compose en vez de una llamada del sistema
	2. Gestionar levantar un docker compose al darle al boton de desactivar en una red y usuario diferentes (HECHO) REVISAR-> Usar la api docker-compose en vez de una llamada del sistema
	3. Que aparezca la ip al lado cuando esté levantado el contenedor (HECHO)
	4 Verificar de manera correcta la estructura de:  (PENDIENTE)
		4.1 Carpeta docker-compose
		4.2 Imagenes docker
		4.3 La estructura de las maquinas virtuales que sea por lo menos una maquina virtual (.ova)
	5. Añadir las flags a las maquinas vulnerables
	6. Usar una plantilla con {% extends 'base.html' %} para usar solo la base
	7.. Generar un Script que se encargue de gestionar la iptables para segmentar la red entre usuarios y el sistema
	-----17-02-2024---------
	-> Poner foto de perfil del usuario:
		a. Que sea accesible unicamente por el usuario su foto
		b. O poner la ruta encriptada y con nombre auxiliar
	-> Se ha cambiado la maquina startrek_payroll para que funcione correctamente cuando se levanta, hay que gestionar la segmentación de red para que sea accesible
		desde la conexón con la VPN (configuración de ip tables)
		-> Información de documentación iptables:
			1. Obtener la ip del cliente: Fichero->sudo cat /var/log/openvpn/status.log tambien esta en /etc/openvpn/ipp.txt
			2. Reglas:
				¡IMPORTANTE!
				====================
				# Bloquear tráfico desde el rango 10.8.0.0/24
				sudo iptables -A FORWARD -s 10.8.0.0/24 -d 172.18.0.4 -j DROP
				# Permitir tráfico desde la IP específica 10.8.0.3
				sudo iptables -A FORWARD -s 10.8.0.3 -d 172.18.0.4 -j ACCEPT
				====================
				APUNTE: Para eliminar una regla: # sudo iptables -D FORWARD 23
			3. Para evitar conectividad entre los usuarios:
	-----20-02-2024---------
	Ahora que estan la iptables configuradas, guardarlas en un fichero justo antes de apagar el sistema para que cuando se encienda puedan volverse a ejecutar y estar todo como establecida
	-> Empezar a meter flags a las imágenes de docker compose y GENERALIZAR más; es decir, obtener otro docker-compose vulnerable y poder levantar uno y otro (PENDIENTE)
	-> Ver si funciona para otros sistemas (PENDIENTE)
	-> Crear un fichero ovpn cuando se registre el usuario en el sistema
	-----22-02-2024---------
REVISAR
-> Modificar la base de datos para que cuando se levante una maquina cambiar activa: FALSE->TRUE tanto en el servidor como en el panel de administracion ocurra lo mismo; esto se hace gestionando todo desde el modelo de datos con un evento. Se tendra en cuenta:
1.levantar la maquina desde linea de comandos; 
2. indicar la ip de la maquina, 
3.establecer las reglas iptables. Rama main
	-----23-02-2024---------
-> Se ha modificado el fichero /etc/sudoers para que el usuario marco pueda ejecutar iptables sin contraseña:
	- Se ha comentado la linea: #%sudo  ALL=(ALL:ALL) ALL
	- Se ha añadido la linea: marco ALL=(ALL:ALL) NOPASSWD:/usr/sbin/iptables, /home/marco/Escritorio/TFG/marpaga_tfg/iptables.sh 
	=>MODIFICAR: Cambiar la ruta donde se encuentra el archivo iptables.sh y el futuro Script para crear usuarios vpn
	-----24-02-2024---------
-> Haciendo script automatización creación de usuario.ovpn, (prueba: micieces, marpagaadmin)
-> Añado en el /etc/sudoers el script para añadir y eliminar clientes vpn al crear un usuario: 
	# marco ALL=(ALL:ALL) NOPASSWD:/usr/sbin/iptables, /home/marco/Escritorio/TFG/marpaga_tfg/iptables.sh, /home/marco/Escritorio/TFG/marpaga_tfg/createUserVPN.sh
	-----25-02-2024---------
-> Haciendo un tunel para poder ver un puerto de mi servidor remoto en el local
	ssh -L 4000:prodiasv18.fis.usal.es:80 -N i1100160@nogal.usal.es
-> Para pasar datos de mi servidor local a mi servidor remoto:
	# scp -o ProxyJump=i1100160@nogal.usal.es -r /home/marco/Escritorio/TFG/marpaga_tfg/ marco@prodiasv18.fis.usal.es:/home/marco/TFG/
-----26-02-2024---------
-> Caso de uso Modificar Constaseña
-> Caso de uso Validar cuenta de usuario:
	+ Creamos un correo electronico:
		marpagamarco@gmail.com -> marpagaadmin2001
	+ Añadimos en los settings:
		EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
		EMAIL_HOST = 'smtp.gmail.com'
		EMAIL_PORT = 587
		EMAIL_USE_TLS = True
		EMAIL_HOST_USER = 'marpagamarco@gmail.com'
		EMAIL_HOST_PASSWORD = 'wpqdzopxecragcyq'
		EMAIL_USE_TLS = True
	+ Tambien los imports correspondientes
	-> Cuando un usuario se registra pero no activa la cuenta durante X tiempo eliminarla (se ha creado managements/commands): HECHO
	-> Modificar el html account_activation_email.html
-> Caso de uso contraseña olvidada: PENDIENTE->MODIFICAR su estetica esta a medio hacer
-----27-02-2024---------
-> Implementar crontab para eliminar los usuarios que no tengan la cuneta activada:
	Opcion 1:
	- Instalo la tarea cron:
		# pip install django-cron
	- Creo el archivo marpaga/cron.py
	- Migro los datos:
		# python3 manage.py migrate django_cron
	- Registro las tareas cron: 
		# python3 manage.py runcrons
	Conclusion: Funciona pero no se ejecuta a la vez por lo tanto se va a usar celery:
	Opcion 2:
	- Instalo celery:
		# pip install celery[redis]
	- Creo un archivo aplicacion_principal/celery.py (No adjunto el conteneido)
	- Instalar en el servidor todo:
		# apt install redis-server
	- Ejecuto los comandos: 
		# celery -A marpaga beat --loglevel=info
		# celery -A marpaga worker --loglevel=info
	Elimino todo: 
		# apt-get remove --purge redis-server -y && apt-get autoremove -y && rm -r /etc/redis && rm -r /var/log/redis && sudo rm -r /var/lib/redis
		Tambien los ficheros tasks.py
	Opcion 3:
	- Finalmente cuando se completa el formulario se crea un hilo que después de 1 minuto se ejecute la eliminación de los usuarios con la cuenta inactiva.
-----28-02-2024---------
-> Mirando como alojar todo en el servidor Apache o Nginx 
	- Lo primero agrupamos todos los ficheros estáticos
	# python3 manage.py collectstatic
	- Obviamente hemos cambiado la variable DEBUG=Flase y STATIC_URL = '/static/'
	- Configuramos el servidor:
	Opcion 1:
	- Instalo gunicorn:
		# pip install gunicorn
	- Se crea un archivo wsgi.py en la misma ruta que manage.py:
		###########
		import os
		from django.core.wsgi import get_wsgi_application
		os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'marpaga.settings')
		application = get_wsgi_application()
		###########
	- Ejecutar gunicorn:
		# gunicorn wsgi -w 4 -b 0.0.0.0:8000
	- Creo un servicio para que corra automáticamente nada más arrancar el ordenador "marpaga_gunicorn.service":
		###########
		[Unit]
		Description=Levanta el servidor de Marpaga una vez se inicie el ordenador
		After=network.target

		[Service]
		User=marco   # Reemplaza con el nombre de tu usuario
		Group=marco    # Reemplaza con el nombre de tu grupo
		WorkingDirectory=/home/marco/Escritorio/TFG/marpaga_tfg
		ExecStart=/home/marco/Escritorio/TFG/virtual/bin/gunicorn wsgi -b 0.0.0.0:8000 -w 4
		Restart=always

		[Install]
		WantedBy=multi-user.target
		###########
	- Lo meto en la ruta: /etc/systemd/system/
		# cp marpaga_gunicorn.service /etc/systemd/system/
	- Reinicio el servicio: 
		# systemctl daemon-reload
	- Activo el servicio:
		# systemctl enable marpaga_gunicorn
	- Bien ahora instalamos Nginx:
	 # apt install nginx
	- Creamos el fichero de configuracion en: /etc/nginx/sites-available/marpaga
		###########
		# /etc/nginx/sites-available/marpaga
		server {
			listen 80;
			server_name marpaga.hopto.org 83.55.64.220;

			location = /favicon.ico { access_log off; log_not_found off; }
			location /static/ {
				root /home/marco/Escritorio/TFG/marpaga_tfg; # Cambiar la ruta a la correspondiente
			}

			location / {
				include proxy_params;
				proxy_pass http://127.0.0.1:8000;
			}
		}
		###########
	- Creamos un enlace simbólico a la ruta /etc/nginx/sites-enables/marpaga
	# sudo ln -s /etc/nginx/sites-available/marpaga /etc/nginx/sites-enabled

	-A los ficheros estáticos le damos permisos:
	# chown -R www-data:www-data /home/marco/Escritorio/TFG/marpaga_tfg/static
	FUNCIONA:
	-> He pasado todo el proyecto a la carpeta: /var/www/html/marpaga_tfg y la he dado todos los permisos tanto a la ruta del proyecto como al entorno virtual.
	¡Con esto esta funcionando el servidor para pasarlo a producción!
	Apuntes Importantes:
	-> Los ficheros estaticos: css, js,... son cargados por el servidor nginx
	-> Toda la parte del backend se ejecuta como el usuario que este establecido en el servicio de gunicorn
	-> PENDIENTE, HACER, establecer certificado ssl y que sea una dirección https
-----29-02-2024---------
-> Estableciendo certificado ssl
	Opcion 1: 
	1. Instalar certbot
	# apt-get install certbot
	2. Instalar el plugin:
	# apt-get install python3-certbot-nginx
	3. Crear lo ficheros:
	# certbot certonly --nginx -d tu_dominio.com
	4. Añadir en setting.py la siguientes lineas:
	# SECURE_SSL_REDIRECT = True
	# SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https') # No sé si es necesario
	5. Editar el fichero de nginx
	# Se han probado varias formas pero no funciona no sé que pasa
	6. Añadir el usuario www-data a docker:
	# usermod -aG docker www-data (PENDIENTE-REVISAR)
	FUNCIONA!! -> IMPORTANTE: Tener los puertos del route abiertos: 80 y 443, modificar el fichero /etc/sudoers o poner la ruta absoluta pero ya funciona
	-> Es importante que el usuario que ejecuta gunicorn pueda hacer todo
	